#!/usr/bin/env python
'''
AVCLASS++ propagator
'''

import os
import sys
path = os.path.dirname(os.path.abspath(__file__))
libpath = os.path.join(path, 'lib/')
sys.path.insert(0, libpath)
import argparse
import hashlib
import glob
import copy
import numpy as np
import pandas as pd
from avclass_labeler import guess_hash
from ember import PEFeatureExtractor
from sklearn.preprocessing import LabelEncoder
from sklearn.semi_supervised import LabelPropagation

def get_file_hash_value(data, hash_type):
    if hash_type == 'md5':
        return hashlib.md5(data).hexdigest()
    elif hash_type == 'sha1':
        return hashlib.sha1(data).hexdigest()
    elif hash_type == 'sha256':
        return hashlib.sha256(data).hexdigest()
    else:
        exit(1)   

def main(args):
    # Prepare labels
    label_hash_list = []
    with open(str(args.labels), 'r') as f:
        for line in f:
            hash_value = line.split('\t')[0].strip()
            label = line.split('\t')[1].strip()

            if label.startswith('SINGLETON'):
                label = 'SINGLETON'

            label_hash_list.append([label, hash_value])

    df = pd.DataFrame(label_hash_list, columns=['label', 'hash'])

    # Prepare features
    hash_features_list = []
    extractor = PEFeatureExtractor()
    hash_type = guess_hash(hash_value)

    for sample in glob.glob(str(args.sampledir) + '/*'):
        with open(sample, 'rb') as f:
            file_data = f.read()
            file_hash_value = get_file_hash_value(file_data, hash_type)
            features = np.array(extractor.feature_vector(file_data), dtype=np.float32)

        hash_features_list.append([file_hash_value, features])

    df2 = pd.DataFrame(hash_features_list, columns=['hash', 'features'])

    # Merge data frames; Samples not included in the .labels file are ignored
    df['features'] = df2['features']
    del df2

    X = df['features'].tolist()
    y = df['label'].tolist()

    # Encode labels
    le = LabelEncoder()
    le.fit(y)
    index_singleton = list(le.classes_).index('SINGLETON')
    y_encoded = le.transform(y)
    y_encoded = [x if x!= index_singleton else -1 for x in y_encoded]

    # Label propagation
    model = LabelPropagation()
    model.fit(X, y_encoded)

    # Decode labels
    y_encoded2 = model.predict(X)
    y2 = [le.classes_[x] for x in y_encoded2]

    # Replace SINGLETON labels with predicted labels
    for i in range(len(y)):
        if y[i] == 'SINGLETON':
            y[i] = y2[i] 

    # Output results with .labels file format
    hash_list = df['hash'].tolist()

    if args.results:
        results = args.results
    else:
        results = args.labels.split('.')[0] + '_pr.labels'

    with open(str(results), 'w+') as f:
        for i in range(len(y)):
            f.writelines(hash_list[i] + '\t' + y[i] + '\n')

if __name__=='__main__':
    argparser = argparse.ArgumentParser(prog='avclass_propagator',
        description='''AVCLASS++ propagator''')

    argparser.add_argument('-labels',
        help='existing .labels file generated by AVCLASS labeler')

    argparser.add_argument('-sampledir',
        help='existing directory with malware samples (PE)')

    argparser.add_argument('-results',
        help='new .labels file (new _pr.labels file is output by default)')

    args = argparser.parse_args()

    if not args.labels and not args.sampledir:
        sys.stderr.write('Both of the following 2 arguments is required: '
                          '-labels, -sampledir\n')
        exit(1)

    main(args)
